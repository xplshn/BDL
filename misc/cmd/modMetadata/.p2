Part from here BUT fix it so that it follows the RULES.
```
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type labeledString struct {
	url  string
	name string
}

type Item struct {
	Name         string  `json:"name"`
	RealName     *string `json:"real_name"`
	Description  string  `json:"description"`
	DownloadURL  string  `json:"download_url"`
	Size         string  `json:"size"`
	B3sum        string  `json:"b3sum"`
	Sha256       string  `json:"sha256"`
	BuildDate    string  `json:"build_date"`
	RepoURL      string  `json:"repo_url"`
	RepoAuthor   string  `json:"repo_author"`
	RepoInfo     string  `json:"repo_info"`
	RepoUpdated  string  `json:"repo_updated"`
	RepoReleased string  `json:"repo_released"`
	RepoVersion  string  `json:"repo_version"`
	RepoStars    string  `json:"repo_stars"`
	RepoLanguage string  `json:"repo_language"`
	RepoLicense  string  `json:"repo_license"`
	RepoTopics   string  `json:"repo_topics"`
	WebURL       string  `json:"web_url"`
	ExtraBins    string  `json:"extra_bins"`
}

func urldecode(encoded string) (string, error) {
	return url.PathUnescape(encoded)
}

func processItems(items []Item, arch string) []Item {
	nameCount := make(map[string]int)
	baseURL := "https://bin.ajam.dev/" + arch + "/Baseutils/"
	for i, item := range items {
		if count, found := nameCount[item.Name]; found {
			nameCount[item.Name] = count + 1
			items[i].Name = fmt.Sprintf("%s#%d", item.Name, count+1)
		} else {
			nameCount[item.Name] = 0
		}

		downloadURLPath := strings.TrimPrefix(item.DownloadURL, "https://")
		downloadURLPath = strings.TrimPrefix(downloadURLPath, "http://")
		downloadURLPath, _ = urldecode(downloadURLPath)

		// Remove the architecture-specific path from the download URL path
		cleanPath := strings.TrimPrefix(downloadURLPath, arch+"/")
		if strings.HasPrefix(cleanPath, baseURL) {
			cleanPath = strings.TrimPrefix(cleanPath, baseURL)
		}

		if cleanPath == item.Name {
			items[i].RealName = nil
		} else {
			items[i].RealName = &cleanPath
		}
	}
	return items
}

func downloadJSON(url string) ([]Item, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var items []Item
	err = json.Unmarshal(body, &items)
	if err != nil {
		return nil, err
	}

	return items, nil
}

func saveJSON(filename string, items []Item) error {
	jsonData, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(filename, jsonData, 0644)
	if err != nil {
		return err
	}

	return nil
}

func main() {
	validatedArchs := []string{"x86_64_Linux", "aarch64_arm64_Linux", "arm64_v8a_Android"}

	for _, arch := range validatedArchs {
		repos := []labeledString{
			{"https://bin.ajam.dev/" + arch + "/METADATA.json", "METADATA"},
			{"https://bin.ajam.dev/" + arch + "/Baseutils/METADATA.json", "Baseutils_METADATA"},
		}

		for _, repo := range repos {
			items, err := downloadJSON(repo.url)
			if err != nil {
				fmt.Printf("Error downloading JSON from %s: %v\n", repo, err)
				continue
			}

			processedItems := processItems(items, arch)

			outputFile := fmt.Sprintf("%s.bigdl_%s.json", repo.name, arch)

			if err := saveJSON(outputFile, processedItems); err != nil {
				fmt.Printf("Error saving JSON to %s: %v\n", outputFile, err)
				continue
			}
			fmt.Printf("Processed and saved to %s\n", outputFile)
		}
	}
}

```

RULES:
1. The real_name cannot be, for example:
2. Use existing Go libraries that are part of the standard library
 ```
  "real_name": "x86_64_Linux/Baseutils/coreutils/bash"
 ```
 it should be:
 ```
   "real_name": "Baseutils/coreutils/bash"
 ```
 Another CORRECT example:
 ```
   "real_name": "bin.ajam.dev/x86_64_Linux/busybox/vi"
 ```
  - Because the first element there is the ValidatedArch[]
  - And Also because what follows after the ValidatedArch is the basepath/basename of the MetadataURLs[1], which is "https://bin.ajam.dev/"+arch+"/Baseutils".
  - real_name's value can also NOT start with the domain of the URL.

More info:
```instructions_why_and_how_and_rules
```
[
  {
    "name": "7z",
    "description": "Unarchiver",
    "download_url": "https://bin.ajam.dev/x86_64_Linux/7z",
    "size": "3.73 MB",
    "b3sum": "125acdc505ed6582ea1daec36c39d16749bbbf58ce2d19bdadaac27ff3b74f23",
    "sha256": "a2728a3dbd244cbb1a04f6a0998f53ec03abb7e3fb30e8e361fa22614c98e8d3",
    "build_date": "2024-06-24T03:39:33",
    "repo_url": "https://github.com/ip7z/7zip",
    "repo_author": "ip7z",
    "repo_info": "7-Zip",
    "repo_updated": "2024-07-05T14:39:53Z",
    "repo_released": "2024-06-19T10:45:51Z",
    "repo_version": "24.07",
    "repo_stars": "447",
    "repo_language": "C++",
    "repo_license": "",
    "repo_topics": "",
    "web_url": "https://www.7-zip.org",
    "extra_bins": ""
  },
```

If there were a duplicate of 7z, it would become:

```
[
  {
    "name": "7z#2",
    "real_name": "7z",
    "description": "7z unarchiver but with additional support for PAX",
    "download_url": "https://bin.ajam.dev/x86_64_Linux/7z",
    "size": "3.73 MB",
    "b3sum": "125acdc505ed6582ea1daec36c39d16749bbbf58ce2d19bdadaac27ff3b74f23",
    "sha256": "a2728a3dbd244cbb1a04f6a0998f53ec03abb7e3fb30e8e361fa22614c98e8d3",
    "build_date": "2024-06-24T03:39:33",
    "repo_url": "https://github.com/ip7z/7zip",
    "repo_author": "ip7z",
    "repo_info": "7-Zip",
    "repo_updated": "2024-07-05T14:39:53Z",
    "repo_released": "2024-06-19T10:45:51Z",
    "repo_version": "24.07",
    "repo_stars": "447",
    "repo_language": "C++",
    "repo_license": "",
    "repo_topics": "",
    "web_url": "https://www.7-zip.org",
    "extra_bins": ""
  },
```

Since download_url points to a file which's file path is the same as "name"'s after removing the domain and the protocol and the repo url directory from it, is in the same dir as the value of the "name" field, thus "name" and "real_name" are the same in this case. If 7z were in another dir, the real_name would be "someDir/7z" for example.
```
